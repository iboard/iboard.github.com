<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Never Look Back: A Phoenix Rises from Rails&#39; Ashes - Andi Altendorfer</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Introduction: The End of a Journey, The Start of Another
Every software developer has a path, a winding road of languages, frameworks, and philosophies that shapes their craft. My own journey has taken me through the structured landscapes of Pascal, the raw power of C&#43;&#43;, and the wild, chaotic frontier of early PHP web development. For a long time, I was a journeyman, picking up tools as I needed them, solving problems, and moving on. Then came the era of frameworks, promising order, productivity, and a &ldquo;right way&rdquo; to build things. And for a significant part of the web&rsquo;s history, the undisputed king of that era was Ruby on Rails." />
	<meta property="og:image" content=""/>
	<meta property="og:url" content="https://iboard.github.io/posts/2025-11-07-never-look-back/">
  <meta property="og:site_name" content="Andi Altendorfer">
  <meta property="og:title" content="Never Look Back: A Phoenix Rises from Rails&#39; Ashes">
  <meta property="og:description" content="Introduction: The End of a Journey, The Start of Another Every software developer has a path, a winding road of languages, frameworks, and philosophies that shapes their craft. My own journey has taken me through the structured landscapes of Pascal, the raw power of C&#43;&#43;, and the wild, chaotic frontier of early PHP web development. For a long time, I was a journeyman, picking up tools as I needed them, solving problems, and moving on. Then came the era of frameworks, promising order, productivity, and a “right way” to build things. And for a significant part of the web’s history, the undisputed king of that era was Ruby on Rails.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-11-07T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-11-07T00:00:00+00:00">
    <meta property="article:tag" content="Elixir">
    <meta property="article:tag" content="Programming">
    <meta property="article:tag" content="Webdev">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Never Look Back: A Phoenix Rises from Rails&#39; Ashes">
  <meta name="twitter:description" content="Introduction: The End of a Journey, The Start of Another Every software developer has a path, a winding road of languages, frameworks, and philosophies that shapes their craft. My own journey has taken me through the structured landscapes of Pascal, the raw power of C&#43;&#43;, and the wild, chaotic frontier of early PHP web development. For a long time, I was a journeyman, picking up tools as I needed them, solving problems, and moving on. Then came the era of frameworks, promising order, productivity, and a “right way” to build things. And for a significant part of the web’s history, the undisputed king of that era was Ruby on Rails.">

        <link href="https://iboard.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://iboard.github.io/css/main.e67317426819e55d53e25594c6c2f5d9954e3b7bd60919d8d75ab322810b0494.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://iboard.github.io/css/dark.441e799130b3fa0fefac68d1528dc12b07af1e8307f46cf17bf48f895b2efeef.css"  disabled />
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://iboard.github.io/">Andi Altendorfer</a>
	</div>
	<nav>
		
		<a href="/">cd /</a>
		
		<a href="/craftsman">/craft</a>
		
		<a href="/posts">/posts</a>
		
		<a href="/archives">/archives</a>
		
		<a href="/about">/about</a>
		
		<a href="/ematrix">/x</a>
		
		<a href="/categories">/c</a>
		
		<a href="/tags">#</a>
		
		| <span id="dark-mode-toggle" onclick="toggleTheme()"><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#sun" />
</svg></span>
		<script src="https://iboard.github.io/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
  <article>
    <div class="post-container">
      
      <div class="post-content">
        <div class="title">
          <h1 class="title">Never Look Back: A Phoenix Rises from Rails&#39; Ashes</h1>
          <div class="meta">
            Posted on Nov 7, 2025
          </div>
        </div>
        
      
      
      <div class="right-toc">
        <div class=""><a href="/tags">#TAGS</a>
          <div class="post-tags">
            
            
            <nav class="nav tags">
              <ul class="tags">
                
                <li><a href="/tags/elixir">elixir</a></li>
                
                <li><a href="/tags/programming">programming</a></li>
                
                <li><a href="/tags/webdev">webdev</a></li>
                
              </ul>
            </nav>
            
            
          </div>
        <strong>#TOC</strong>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#introduction-the-end-of-a-journey-the-start-of-another">Introduction: The End of a Journey, The Start of Another</a></li>
    <li><a href="#chapter-1-the-allure-of-the-ruby-slippers">Chapter 1: The Allure of the Ruby Slippers</a></li>
    <li><a href="#chapter-2-the-cracks-in-the-foundation">Chapter 2: The Cracks in the Foundation</a></li>
    <li><a href="#chapter-3-a-new-paradigm-the-elixir-of-life">Chapter 3: A New Paradigm: The Elixir of Life</a></li>
    <li><a href="#chapter-4-phoenix---the-framework-that-respects-you">Chapter 4: Phoenix - The Framework That Respects You</a></li>
    <li><a href="#chapter-5-the-real-time-revolution-with-liveview">Chapter 5: The Real-Time Revolution with LiveView</a></li>
    <li><a href="#chapter-6-performance-scalability-and-peace-of-mind">Chapter 6: Performance, Scalability, and Peace of Mind</a></li>
    <li><a href="#chapter-7-why-i-havent-looked-back">Chapter 7: Why I Haven&rsquo;t Looked Back</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
        </div>
      </div>
      
      
        <section class="body"><h2 id="introduction-the-end-of-a-journey-the-start-of-another">Introduction: The End of a Journey, The Start of Another</h2>
<p>Every software developer has a path, a winding road of languages, frameworks, and philosophies that shapes their craft. My own journey has taken me through the structured landscapes of Pascal, the raw power of C++, and the wild, chaotic frontier of early PHP web development. For a long time, I was a journeyman, picking up tools as I needed them, solving problems, and moving on. Then came the era of frameworks, promising order, productivity, and a &ldquo;right way&rdquo; to build things. And for a significant part of the web&rsquo;s history, the undisputed king of that era was Ruby on Rails.</p>
<p>I, like many others, was drawn to its siren song. The promise of &ldquo;developer happiness,&rdquo; the sheer speed of scaffolding a new application, the elegance of the Ruby language—it was intoxicating. I built things with Rails. I saw its power. But as my main projects matured and my focus shifted towards long-term stability, scalability, and a different kind of developer experience, I found myself drifting away.</p>
<p>Then I discovered Elixir and the Phoenix framework. It wasn&rsquo;t just a new tool; it was a new way of thinking about building software for the web. After completing my first major project in Phoenix, I powered down the Rails server for the last time on a production app and, without any conscious decision or dramatic fanfare, I simply never went back. This isn&rsquo;t a story of hate for a technology I once used. It&rsquo;s a story of finding a better home. This is a review of that journey, an exploration of the fundamental differences that made looking back an impossibility. It&rsquo;s about why, for me, a Phoenix has truly risen from the ashes of my Rails days.</p>
<h2 id="chapter-1-the-allure-of-the-ruby-slippers">Chapter 1: The Allure of the Ruby Slippers</h2>
<p>You can&rsquo;t talk about leaving Rails without first acknowledging its profound impact and undeniable appeal. To deny the genius of its design, especially for its time, would be disingenuous. When Rails exploded onto the scene, it was a revelation.</p>
<ol>
<li>
<p><strong>The Magic of Convention over Configuration</strong></p>
<p>The core philosophy of Rails was simple: let the framework make the decisions. Where do models go? In <code>app/models</code>. Controllers? <code>app/controllers</code>. The database table for the <code>User</code> model is <code>users</code>. This seems obvious now, but at the time, it eliminated countless hours of boilerplate configuration and debate.</p>
<p>The pinnacle of this magic was the <code>rails new my_app</code> command. In a few moments, you had a fully structured, working web application, complete with a database connection, asset pipeline, and server. Then came scaffolding: <code>rails generate scaffold Post title:string content:text</code>. With one command, you had a model, a database migration, a controller with all seven RESTful actions, and the corresponding views. It felt like you were cheating. You could build a functional CRUD application in an afternoon. This was the &ldquo;10x developer&rdquo; promise made real, and it was incredibly powerful.</p>
</li>
<li>
<p><strong>ActiveRecord and the Beauty of Ruby</strong></p>
<p>Ruby itself was a huge part of the draw. It&rsquo;s a language designed for beauty and programmer happiness. The syntax is clean, expressive, and reads almost like English. Blocks, mixins, and metaprogramming capabilities made it incredibly flexible.</p>
<p>ActiveRecord, the ORM (Object-Relational Mapper) for Rails, was a masterclass in leveraging this flexibility.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ruby" data-lang="ruby"><span style="display:flex;"><span><span style="color:#75715e"># Find a user by ID</span>
</span></span><span style="display:flex;"><span>user <span style="color:#f92672">=</span> <span style="color:#66d9ef">User</span><span style="color:#f92672">.</span>find(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Find all posts for that user, ordered by creation date</span>
</span></span><span style="display:flex;"><span>posts <span style="color:#f92672">=</span> user<span style="color:#f92672">.</span>posts<span style="color:#f92672">.</span>order(<span style="color:#e6db74">created_at</span>: <span style="color:#e6db74">:desc</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a new post</span>
</span></span><span style="display:flex;"><span>new_post <span style="color:#f92672">=</span> user<span style="color:#f92672">.</span>posts<span style="color:#f92672">.</span>create(<span style="color:#e6db74">title</span>: <span style="color:#e6db74">&#34;My New Post&#34;</span>, <span style="color:#e6db74">content</span>: <span style="color:#e6db74">&#34;Hello, world!&#34;</span>)
</span></span></code></pre></div><p>It was fluid, intuitive, and it just worked. You could interact with your database as if it were just another collection of Ruby objects. The complexity of SQL was abstracted away, leaving you to focus on your application&rsquo;s logic. It was, in a word, magical.</p>
</li>
</ol>
<h2 id="chapter-2-the-cracks-in-the-foundation">Chapter 2: The Cracks in the Foundation</h2>
<p>For a long time, the magic was enough. But as applications grow, as user loads increase, and as teams expand, the very magic that made Rails so initially appealing can start to feel like a curse. The shortcuts become technical debt, and the abstractions hide performance bottlenecks that are difficult to diagnose and fix.</p>
<ol>
<li>
<p><strong>When Magic Becomes Obfuscation</strong></p>
<p>The &ldquo;convention over configuration&rdquo; mantra works beautifully until you need to deviate from the convention. When you need to do something non-standard, you suddenly find yourself fighting the framework, digging through layers of abstraction to understand how to override the &ldquo;magic.&rdquo;</p>
<p>A classic example is ActiveRecord callbacks. <code>before_save</code>, <code>after_create</code>, <code>after_commit</code>. These seem like convenient hooks, but they can quickly create a tangled web of side effects. A simple <code>user.save</code> might trigger a cascade of emails, API calls, and data updates in other models. It becomes incredibly difficult to reason about the flow of data and to test components in isolation. The magic that once helped you now hides the complexity, making the system brittle and unpredictable.</p>
</li>
<li>
<p><strong>The Elephant in the Room: Concurrency and the GIL</strong></p>
<p>The biggest challenge for any maturing Rails application is performance and scalability. At the heart of this challenge is the Global Interpreter Lock (GIL) in the standard MRI (Matz&rsquo;s Ruby Interpreter). The GIL means that even on a multi-core processor, only one thread of Ruby code can execute at a time.</p>
<p>This has profound implications for a web server. When a request comes in that involves I/O (like a database query or an external API call), the process can release the lock, allowing another thread to run. This is concurrency, but it&rsquo;s not parallelism. You can&rsquo;t perform multiple CPU-intensive tasks simultaneously.</p>
<p>The practical result is that scaling a Rails application often means scaling <em>out</em> (adding more machines) rather than scaling <em>up</em> (using more powerful machines). To handle high traffic, you run multiple server processes on each machine, sitting behind a load balancer. To handle background work, you rely on separate systems like Sidekiq or Resque, which have their own processes and memory overhead. The architecture becomes a complex, distributed system by necessity, not by design.</p>
</li>
<li>
<p><strong>Architectural Patterns: Fat Models, Skinny Controllers</strong></p>
<p>Rails encourages a pattern of &ldquo;Fat Models, Skinny Controllers.&rdquo; The idea is to keep your controllers lean, delegating all business logic to the ActiveRecord models. This sounds good in theory, but in a large application, it leads to <code>User.rb</code> and <code>Order.rb</code> files that are thousands of lines long. These &ldquo;god objects&rdquo; become responsible for everything from data validation and persistence to sending emails, processing payments, and generating reports.</p>
<p>They violate the Single Responsibility Principle on a grand scale. They are difficult to test, impossible to reason about, and a nightmare to refactor. The community has come up with solutions—Service Objects, Form Objects, Presenters—but these are bolt-on patterns, not something the framework guides you towards naturally. You have to actively fight the framework&rsquo;s initial pull to avoid this architectural dead end.</p>
</li>
</ol>
<h2 id="chapter-3-a-new-paradigm-the-elixir-of-life">Chapter 3: A New Paradigm: The Elixir of Life</h2>
<p>My discovery of Elixir wasn&rsquo;t a sudden epiphany but a gradual realization that there had to be a better way to address the problems I was facing. Elixir, a dynamic, functional language built on the Erlang Virtual Machine (BEAM), offered a fundamentally different set of answers.</p>
<ol>
<li>
<p><strong>Functional Programming vs. Object-Oriented</strong></p>
<p>Moving from Ruby to Elixir is a shift from an Object-Oriented (OO) mindset to a Functional Programming (FP) one. In Ruby, everything is an object. You create instances of classes, these instances hold state, and you call methods on them that mutate that state.</p>
<p>In Elixir, the primary building blocks are functions. Data is separate from behavior. And, crucially, data is <em>immutable</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span><span style="color:#75715e"># In Elixir, you don&#39;t change data, you transform it.</span>
</span></span><span style="display:flex;"><span>my_map <span style="color:#f92672">=</span> %{<span style="color:#e6db74">name</span>: <span style="color:#e6db74">&#34;Andi&#34;</span>, <span style="color:#e6db74">role</span>: <span style="color:#e6db74">&#34;developer&#34;</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># This doesn&#39;t change my_map. It returns a NEW map.</span>
</span></span><span style="display:flex;"><span>updated_map <span style="color:#f92672">=</span> <span style="color:#a6e22e">Map</span><span style="color:#f92672">.</span>put(my_map, <span style="color:#e6db74">:role</span>, <span style="color:#e6db74">&#34;senior developer&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># my_map is still %{name: &#34;Andi&#34;, role: &#34;developer&#34;}</span>
</span></span></code></pre></div><p>This seems like a small difference, but it has massive consequences. Immutability eliminates a whole class of bugs related to shared, mutable state. You never have to wonder if some other part of the system has unexpectedly changed the data you&rsquo;re working with. This makes code easier to reason about, easier to test, and, most importantly, makes concurrency trivial and safe.</p>
</li>
<li>
<p><strong>Pattern Matching: A Developer&rsquo;s Superpower</strong></p>
<p>If there&rsquo;s one feature that defines the Elixir experience, it&rsquo;s pattern matching. It&rsquo;s not just a <code>switch</code> statement on steroids; it&rsquo;s a way of controlling program flow and destructuring data at the same time.</p>
<p>You can pattern match on function heads:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> handle_request(%{<span style="color:#e6db74">method</span>: <span style="color:#e6db74">&#34;GET&#34;</span>, <span style="color:#e6db74">path</span>: <span style="color:#e6db74">&#34;/users/&#34;</span> <span style="color:#f92672">&lt;&gt;</span> id}) <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Logic to get user by id</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> handle_request(%{<span style="color:#e6db74">method</span>: <span style="color:#e6db74">&#34;POST&#34;</span>, <span style="color:#e6db74">path</span>: <span style="color:#e6db74">&#34;/users&#34;</span>, <span style="color:#e6db74">body</span>: body}) <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># Logic to create a user with the body</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> handle_request(_request) <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># A catch-all for requests we don&#39;t handle</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>This is incredibly expressive. The function signature itself documents what it expects. The <code>_request</code> catch-all at the end is a common pattern that acts as an &ldquo;else&rdquo; and prevents unhandled cases from crashing (or rather, allows them to crash explicitly, which we&rsquo;ll get to).</p>
<p>You can also use it with the <code>case</code> statement to handle different outcomes:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">Repo</span><span style="color:#f92672">.</span>insert(changeset) <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  {<span style="color:#e6db74">:ok</span>, user} <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Success! Do something with the created user.</span>
</span></span><span style="display:flex;"><span>    {<span style="color:#e6db74">:ok</span>, user}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  {<span style="color:#e6db74">:error</span>, changeset} <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Failure! The changeset tells us exactly what went wrong.</span>
</span></span><span style="display:flex;"><span>    {<span style="color:#e6db74">:error</span>, changeset}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>This forces you to handle both the success and failure paths. It makes &ldquo;happy path&rdquo; programming difficult and encourages robust, resilient code from the very beginning.</p>
</li>
<li>
<p><strong>The BEAM: A Battle-Tested Foundation</strong></p>
<p>Perhaps the most significant advantage Elixir has is its runtime: the BEAM. The Erlang VM was designed from the ground up by Ericsson in the 1980s to build fault-tolerant, highly concurrent telecommunications systems—systems that needed to run with &ldquo;nine nines&rdquo; of uptime (99.9999999%).</p>
<p>The BEAM&rsquo;s concurrency model is not based on threads but on millions of tiny, lightweight processes that are completely isolated from each other. They don&rsquo;t share memory. They communicate by sending messages. A web request in a Phoenix application is handled by its own process. A WebSocket connection has its own process.</p>
<p>The BEAM&rsquo;s scheduler is pre-emptive and runs on all available CPU cores. This means you get true parallelism out of the box. A single, powerful server can handle an enormous amount of concurrent work without breaking a sweat. The GIL is simply not a factor. The architectural complexity of running separate worker processes for background jobs melts away. You can just <code>spawn</code> a new process. It&rsquo;s that simple.</p>
</li>
</ol>
<h2 id="chapter-4-phoenix---the-framework-that-respects-you">Chapter 4: Phoenix - The Framework That Respects You</h2>
<p>If Elixir is the language, Phoenix is its web-facing manifestation. And while it shares some superficial similarities with Rails (it has controllers, views, and a router), its philosophy is fundamentally different. Phoenix values explicitness over magic.</p>
<ol>
<li>
<p><strong>Ecto and Changesets: Sanity in Data Handling</strong></p>
<p>Ecto is the database wrapper and query language for Phoenix. It is not an ActiveRecord clone. Its most important innovation is the <code>Changeset</code>.</p>
<p>In Rails, validation rules live on the model. When you call <code>model.valid?</code>, it checks its internal state. When you call <code>model.update(params)</code>, it tries to update its attributes and save, all in one go.</p>
<p>In Phoenix, data and validation are decoupled. A changeset is a dedicated data structure that represents a <em>proposed change</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> changeset(user, attrs) <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  user
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|&gt;</span> cast(attrs, [<span style="color:#e6db74">:name</span>, <span style="color:#e6db74">:email</span>])
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|&gt;</span> validate_required([<span style="color:#e6db74">:name</span>, <span style="color:#e6db74">:email</span>])
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|&gt;</span> validate_format(<span style="color:#e6db74">:email</span>, <span style="color:#e6db74">~r/@/</span>)
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">|&gt;</span> unique_constraint(<span style="color:#e6db74">:email</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>This function takes a <code>user</code> struct and a map of <code>attrs</code> (the incoming parameters). It then pipes this data through a series of transformations and validations.</p>
<ol>
<li><code>cast</code>: Specifies which attributes are allowed to be changed. This is a security-first default.</li>
<li><code>validate_required</code>: Checks for presence.</li>
<li><code>validate_format</code>: Checks against a regex.</li>
<li><code>unique_constraint</code>: Checks for uniqueness at the database level.</li>
</ol>
<p>The key is that this function <em>returns</em> a changeset. The changeset contains the original data, the proposed changes, a list of validations, and a <code>valid?</code> flag. No side effects have occurred. The database has not been touched.</p>
<p>Your controller then explicitly uses this changeset to perform the database operation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span><span style="color:#66d9ef">case</span> <span style="color:#a6e22e">MyApp.Accounts</span><span style="color:#f92672">.</span>create_user(params) <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  {<span style="color:#e6db74">:ok</span>, user} <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Redirect to show page</span>
</span></span><span style="display:flex;"><span>  {<span style="color:#e6db74">:error</span>, %<span style="color:#a6e22e">Ecto.Changeset</span>{} <span style="color:#f92672">=</span> changeset} <span style="color:#f92672">-&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Re-render the form, passing the changeset back</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># so we can display detailed error messages.</span>
</span></span><span style="display:flex;"><span>    render(conn, <span style="color:#e6db74">&#34;new.html&#34;</span>, <span style="color:#e6db74">changeset</span>: changeset)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>This explicitness is liberating. The flow of data is crystal clear. There is no hidden state, no callback spaghetti. You can see the transformation of data from raw parameters to a validated changeset to a database insert. It&rsquo;s more verbose than Rails, but that verbosity buys you clarity, security, and maintainability.</p>
</li>
<li>
<p><strong>Plug: A Composable Architecture</strong></p>
<p>Phoenix is built on a specification called <code>Plug</code>. A plug is just a function that takes a connection struct (<code>conn</code>) and some options, and returns a (possibly modified) <code>conn</code>.</p>
<p>Your entire request-response lifecycle is a pipeline of plugs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span>pipeline <span style="color:#e6db74">:browser</span> <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  plug <span style="color:#e6db74">:accepts</span>, [<span style="color:#e6db74">&#34;html&#34;</span>]
</span></span><span style="display:flex;"><span>  plug <span style="color:#e6db74">:fetch_session</span>
</span></span><span style="display:flex;"><span>  plug <span style="color:#e6db74">:fetch_live_flash</span>
</span></span><span style="display:flex;"><span>  plug <span style="color:#e6db74">:protect_from_forgery</span>
</span></span><span style="display:flex;"><span>  plug <span style="color:#e6db74">:put_secure_browser_headers</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span></code></pre></div><p>This is from the router. When a request comes in, it flows through each of these plugs in order. <code>fetch_session</code> loads the session data into the <code>conn</code>. <code>protect_from_forgery</code> validates the CSRF token. Controllers themselves are just plugs. This is a beautifully simple and composable idea. It&rsquo;s Elixir&rsquo;s functional nature applied to the web. It&rsquo;s explicit, easy to follow, and easy to test.</p>
</li>
</ol>
<h2 id="chapter-5-the-real-time-revolution-with-liveview">Chapter 5: The Real-Time Revolution with LiveView</h2>
<p>If Ecto and Plug were the features that sold me on Phoenix&rsquo;s architecture, LiveView was the feature that blew my mind and made it impossible to go back.</p>
<p>Phoenix LiveView is a library that allows you to build rich, real-time user experiences with server-rendered HTML. Let that sink in. You get the interactive, responsive feel of a single-page application (SPA) built with React or Vue, but you write almost no JavaScript.</p>
<ol>
<li>
<p><strong>How It Works</strong></p>
<p>When a user first requests a LiveView page, the server renders the full HTML, just like a traditional request. It then establishes a persistent WebSocket connection between the client and the server. From that point on, every interaction—a button click, a form submission, a key press—sends a tiny message over the WebSocket to a dedicated LiveView process on the server.</p>
<p>The LiveView process handles the event, updates its state, and re-renders its template. But it doesn&rsquo;t send the whole HTML page back. It intelligently diffs the new HTML with the old HTML and sends only the minimal changes needed to update the page. The client-side JavaScript, which is completely transparent to you, receives this tiny diff and surgically updates the DOM.</p>
<p>The result is an incredibly fast and responsive user experience. The state lives on the server, in an Elixir process, which means you have access to the full power of the BEAM.</p>
</li>
<li>
<p><strong>The End of the SPA Divide</strong></p>
<p>For years, the dominant paradigm for building interactive web apps was to create a REST or GraphQL API on the backend and a completely separate JavaScript SPA on the frontend. This has always been a source of immense complexity.</p>
<ol>
<li>You need two codebases, often in two different languages.</li>
<li>You need to manage state on both the client and the server and keep them in sync.</li>
<li>You have to deal with authentication, routing, and validation in two separate places.</li>
<li>You double your hiring complexity and create a division in your team (frontend vs. backend).</li>
</ol>
<p>LiveView collapses this divide. Your rendering logic, your event handling, and your state all live in one place, on the server, written in Elixir. You can build a feature like auto-suggest search, which used to require significant JavaScript, in just a few lines of Elixir code.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-elixir" data-lang="elixir"><span style="display:flex;"><span><span style="color:#75715e"># In your LiveView</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> handle_event(<span style="color:#e6db74">&#34;search&#34;</span>, %{<span style="color:#e6db74">&#34;query&#34;</span> <span style="color:#f92672">=&gt;</span> query}, socket) <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># The state is updated, LiveView re-renders,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#75715e"># and the diff is sent to the client.</span>
</span></span><span style="display:flex;"><span>  {<span style="color:#e6db74">:noreply</span>, assign(socket, <span style="color:#e6db74">results</span>: search_database(query))}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># In your template</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>input type<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;text&#34;</span> phx<span style="color:#f92672">-</span>change<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;search&#34;</span> phx<span style="color:#f92672">-</span>debounce<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;300&#34;</span> <span style="color:#f92672">/&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;</span>ul<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">%</span><span style="color:#f92672">=</span> <span style="color:#66d9ef">for</span> result <span style="color:#f92672">&lt;-</span> <span style="color:#a6e22e">@results</span> <span style="color:#66d9ef">do</span> <span style="color:#960050;background-color:#1e0010">%</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;</span>li<span style="color:#f92672">&gt;&lt;</span><span style="color:#960050;background-color:#1e0010">%</span><span style="color:#f92672">=</span> result<span style="color:#f92672">.</span>name <span style="color:#960050;background-color:#1e0010">%</span><span style="color:#f92672">&gt;&lt;/</span>li<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">%</span> <span style="color:#66d9ef">end</span> <span style="color:#960050;background-color:#1e0010">%</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/</span>ul<span style="color:#f92672">&gt;</span>
</span></span></code></pre></div><p>That&rsquo;s it. A real-time search box. No API endpoints, no JSON serialization, no client-side state management. It feels like cheating in a way that even Rails scaffolding never did. Rails has Hotwire and Turbo, which are steps in a similar direction, but they don&rsquo;t have the stateful server-side process that makes LiveView so powerful and seamless.</p>
</li>
</ol>
<h2 id="chapter-6-performance-scalability-and-peace-of-mind">Chapter 6: Performance, Scalability, and Peace of Mind</h2>
<p>This brings us back to the foundation: the BEAM. All these amazing features—LiveView, the concurrency—are possible because of the underlying runtime.</p>
<ol>
<li>
<p><strong>Massive Concurrency is the Default</strong></p>
<p>Every user connected to a LiveView has their own process on the server. This means you can have tens of thousands, or even hundreds of thousands, of simultaneous users connected to a single server, and the system barely flinches. Each process has its own state, completely isolated from the others. A crash in one user&rsquo;s LiveView process has zero impact on any other user.</p>
<p>This is the &ldquo;fault tolerance&rdquo; that Erlang is famous for. The philosophy is not to write defensive code to prevent crashes. The philosophy is &ldquo;let it crash.&rdquo;</p>
</li>
<li>
<p><strong>Supervisors: The Safety Net</strong></p>
<p>In an Elixir/Phoenix application, your processes are organized into a supervision tree. A supervisor&rsquo;s only job is to watch its child processes. If a child process dies for any reason—an unhandled exception, a bug, a database connection dropping—the supervisor will, according to a strategy you define, restart it.</p>
<p>This creates an incredibly resilient system. A transient error might kill a single user&rsquo;s LiveView process, but the supervisor will instantly restart it in a known, clean state. The user might see a flicker on their screen, but the application as a whole remains healthy. This gives you a level of operational peace of mind that is hard to describe until you&rsquo;ve experienced it. You sleep better at night.</p>
</li>
</ol>
<h2 id="chapter-7-why-i-havent-looked-back">Chapter 7: Why I Haven&rsquo;t Looked Back</h2>
<p>This is not an indictment of Ruby on Rails. Rails is a brilliant framework. For a simple CRUD application, a marketing site, or a prototype, its speed and ease of use are nearly unmatched. The gem ecosystem is vast, and the community is enormous and mature.</p>
<p>But for the applications I build today—interactive, long-running, real-time systems that need to be both scalable and maintainable—the trade-offs that Rails makes are no longer the right ones for me.</p>
<ol>
<li>The initial &ldquo;magic&rdquo; of Rails became a long-term liability, hiding complexity and making refactoring difficult. Phoenix&rsquo;s explicitness, while more verbose, provides a clarity that pays dividends over the life of a project.</li>
<li>The performance and concurrency limitations of the Ruby MRI required a complex and expensive architecture of multiple processes and machines. The BEAM gives me true parallelism and massive concurrency on a single server, for free.</li>
<li>The traditional backend/frontend split, with all its inherent complexity, is elegantly solved by Phoenix LiveView, dramatically increasing productivity and simplifying the entire development process.</li>
<li>The &ldquo;let it crash&rdquo; philosophy and supervision trees of Elixir/BEAM provide a level of fault tolerance and resilience that makes applications fundamentally more robust.</li>
</ol>
<h2 id="conclusion">Conclusion</h2>
<p>My journey away from Rails and towards Elixir and Phoenix was not about chasing the new hotness. It was a search for a better way to build for the modern web. It was about finding a toolset that aligns with the demands of real-time interactivity, scalability, and long-term maintainability.</p>
<p>I found that in Elixir&rsquo;s functional purity and the BEAM&rsquo;s battle-hardened concurrency. I found it in Phoenix&rsquo;s explicit and well-architected design. And I found it, most profoundly, in the revolutionary simplicity of LiveView.</p>
<p>I still respect Rails for what it is and the revolution it started. But the problems it solves are, for me, problems of a bygone era. The future of the web is concurrent, real-time, and resilient. And for that future, my tool of choice is Phoenix. I haven&rsquo;t looked back, not because I dislike the past, but because the future is just that much brighter.</p>
</section>
      </div>


    </article>
</main>
<footer>
  <div class="footer-wrap -small"><a class="soc" href="https://github.com/iboard" rel="me" title="GitHub"
      ><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github" />
</svg></a
    ><a class="border"></a><a class="soc" href="https://bsky.app/altendorfer.at" rel="me" title="Bsky"
      ><svg class="feather">
   <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#target" />
</svg></a
    ><a class="border"></a><div class="footer-info">
      2025 
      <a href="/about">© Andi Altendorfer</a> | 
      <a href="/about/license">License</a> | Built with
      <a href="https://gohugo.io">Hugo</a>
    </div>
  </div>
</footer>
  
</div>
    </body>
</html>
